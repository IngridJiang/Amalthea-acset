
import "http://vitruv.tools/reactionsparser/model" as ascet
import "http://vitruv.tools/reactionsparser/model2" as amalthea

reactions: amalthea2ascet
in reaction to changes in amalthea
execute actions in ascet

// insert a System, which is the root element of model, into an instance of model
// as a reaction, an element of type Root should be created, persisted relatively, 
// and a correspondence should be added (see the called routine)
reaction ComponentContainerInsertedAsRoot {
	after element amalthea::ComponentContainer inserted as root
  // newValue refers to the newly inserted element of type System (provided by the reactions runtime environment at runtime)
	call createAndRegisterRootComponentContainer(newValue)
}

routine createAndRegisterRootComponentContainer(amalthea::ComponentContainer componentContainer) {
	match {
    // we do only want to create a new corresponding Root if we not have one already and the old one has, e.g., only been moved
		require absence of ascet::AscetModule corresponding to componentContainer
	}
  create {
    // short way of using the respective Factory calls, which would be used in the update-block
    val mRoot = new ascet::AscetModule
  }
	update {
    // save the newly created AscetModule element at the specified location
    //    persistProjectRelative(componentContainer, mRoot, new File("").toString() + "example.model2")
	      persistProjectRelative(componentContainer, mRoot,  "example.model2")
    // register the correspondence so we can find mRoot later, if we modify something in system and need to adapt mRoot accordingly
		addCorrespondenceBetween(componentContainer, mRoot)
	}
}


reaction TaskDeleted {
	after element amalthea::Task deleted
	call deleteTask(affectedEObject)
}

routine deleteTask (amalthea::Task task){
	match{
		val ascettask = retrieve ascet::Task corresponding to task
	}
	update{
        if (ascettask !== null) {
			removeObject(ascettask)
			removeCorrespondenceBetween(task, ascettask)
		}     
	}
	
}

reaction TaskCreated {
	after element amalthea::Task inserted in amalthea::ComponentContainer[tasks]
		call createAscetTask(newValue,affectedEObject)
}


routine createAscetTask(amalthea::Task task, amalthea::ComponentContainer container){
	update {
		println("[Reaction] createAscetTask routine CALLED!")
		println("  - Task: " + task.name)
		println("  - Container: " + container)

		val String userMsg = "A Task has been created. Please decide whether and which corresponding ASCET Task should be created."

        val initTaskOption = "Create InitTask"
        val periodicTaskOption = "Create PeriodicTask"
        val softwareTaskOption = "Create SoftwareTask"
        val timeTableTaskOption = "Create TimeTableTask"
        val doNothingOption = "Decide Later"

        val String[] options = #[
            initTaskOption,
            periodicTaskOption,
            softwareTaskOption,
            timeTableTaskOption,
            doNothingOption
        ]

        println("[Reaction] About to call userInteractor.startInteraction()...")
        val Integer selected = userInteractor
        .singleSelectionDialogBuilder
        .message(userMsg)
        .choices(options)
        .startInteraction()
        println("[Reaction] userInteractor returned: " + selected)

        // Process user choice with symbolic execution
        var Integer symbolicSelected = selected
        if (selected !== null) {
            try {
                // Get or create tag for this user interaction with tag reuse support
                // Use fully qualified name: ClassName:MethodName:variableName
                val qualifiedName = "CreateAscetTaskRoutine:execute:userChoice"

                // Call GaletteSymbolicator.getOrMakeSymbolicInt to handle tag reuse
                // This method now returns a tagged Integer directly
                val symbolicatorClass = Class.forName("edu.neu.ccs.prl.galette.concolic.knarr.runtime.GaletteSymbolicator")
                val getOrMakeMethod = symbolicatorClass.getMethod("getOrMakeSymbolicInt",
                    String, Integer.TYPE, Integer.TYPE, Integer.TYPE)

                // getOrMakeSymbolicInt now returns the tagged value directly
                val taggedSelected = getOrMakeMethod.invoke(null, qualifiedName, selected,
                    Integer.valueOf(0), Integer.valueOf(options.size - 1)) as Integer

                // Use symbolicVitruviusChoice to record switch constraints
                val symbolicClass = Class.forName("edu.neu.ccs.prl.galette.concolic.knarr.runtime.SymbolicComparison")
                val method = symbolicClass.getMethod("symbolicVitruviusChoice", Integer, Integer.TYPE, Integer.TYPE)
                symbolicSelected = method.invoke(null, taggedSelected,
                    Integer.valueOf(0), Integer.valueOf(options.size - 1)) as Integer
                println("[Reaction] Processed user choice with symbolic execution (tag reuse enabled)")
            } catch (Exception e) {
                println("[Reaction] Symbolic processing failed: " + e.message)
                e.printStackTrace()
                // Fall back to concrete value
                symbolicSelected = selected
            }
        }

        switch (symbolicSelected) {
            case 0: {
                // Switch constraint already recorded by symbolicVitruviusChoice
                createInitTask(task,container)
            }
            case 1: {
                // Switch constraint already recorded by symbolicVitruviusChoice
                createPeriodicTask(task,container)
            }
            case 2: {
                // Switch constraint already recorded by symbolicVitruviusChoice
                createSoftwareTask(task,container)
            }
            case 3: {
                // Switch constraint already recorded by symbolicVitruviusChoice
                createTimeTableTask(task,container)
            }
            case 4: {
                // Switch constraint already recorded by symbolicVitruviusChoice
                // no action
            }
        }

	}
}

routine createInitTask(amalthea::Task task, amalthea::ComponentContainer container){
	
	match {
		val AscetModule = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::InitTask corresponding to task
		 
	}
	create {
		val initTask = new ascet::InitTask
	}
	update {
		AscetModule.tasks += initTask
		initTask.name = task.name
		addCorrespondenceBetween(initTask, container)
		
	}
}

routine createPeriodicTask(amalthea::Task task, amalthea::ComponentContainer container){
	
	match {
		val AscetModule = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::PeriodicTask corresponding to task
		 
	}
	create {
		val periodicTask = new ascet::PeriodicTask
	}
	update {
		AscetModule.tasks += periodicTask
		periodicTask.name = task.name
		periodicTask.delay = 0.10
		periodicTask.period = 1.0
		addCorrespondenceBetween(periodicTask, container)
		
	}
}


routine createSoftwareTask(amalthea::Task task, amalthea::ComponentContainer container){
	
	match {
		val AscetModule = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::SoftwareTask corresponding to task
		 
	}
	create {
		val softwareTask = new ascet::SoftwareTask
	}
	update {
		AscetModule.tasks += softwareTask
		softwareTask.name = task.name
		addCorrespondenceBetween(softwareTask, container)
		
	}
}

routine createTimeTableTask(amalthea::Task task, amalthea::ComponentContainer container){
	
	match {
		val AscetModule = retrieve ascet::AscetModule corresponding to container
		require absence of ascet::TimeTableTask corresponding to task
		 
	}
	create {
		val timeTableTask = new ascet::TimeTableTask
	}
	update {
		AscetModule.tasks += timeTableTask
		timeTableTask.name = task.name
		addCorrespondenceBetween(timeTableTask, container)
		
	}
}

